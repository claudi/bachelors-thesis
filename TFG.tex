\RequirePackage[l2tabu]{nag}
\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{biblatex}
\bibliography{refs.bib}
\usepackage{minted}
\usepackage[hidelinks, pdfencoding=auto]{hyperref}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}[theorem]{Example}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}

\DeclareMathOperator{\Obj}{Obj}
\DeclareMathOperator{\Hom}{Hom}

\newcommand{\id}{\mathrm{id}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Hask}{\ensuremath{\mathrm{Hask}}}
\newcommand{\ev}{\mathrm{ev}}

\newcommand{\cat}[1]{\mathcal{#1}}

\newcommand{\ie}{{i}.{e}., }
\newcommand{\eg}{{e}.{g}. }

\title{Monads in Haskell}
\author{Claudi Lleyda MoltÃ³}
\date{}

\begin{document}
\maketitle
\begin{abstract}
    Upon observing that applying a certain restriction to functions in
    programming, we obtain some substantial benefits but also some important
    apparent limitations, we introduce an abstraction through category theory
    that seems to solve all of the deficits, leaving us in a ``all of the good,
    none of the bad'' situation. We also see how this abstraction can be
    successfully implemented in a real-life programming language, namely
    Haskell.
\end{abstract}
\tableofcontents
\clearpage

\section{Motivation}
\label{sec:motivation}
We begin with an observation: functions found in computer programming may not
behave like functions in mathematics.

Unfortunately, it is common to call computer functions and mathematical
functions both functions. In this report we will do so, as it is usually clear
by the context, and only specifying when there might be confusion. In these
situations, we may refer to a computer function as a~\emph{procedure}.

An example of this is the \mintinline{C}{malloc()} function found in
the~\mintinline{C}{stdlib.h} library in the~\mintinline{C}{C} programming
language, which takes a size in number of bits as input and outputs an unique
pointer to an address to a block of memory allocated to fit the requested size,
which is marked as reserved. This function

\begin{enumerate}
    \item generally outputs a different pointer on calls with the same input,
    \item modifies global state by marking allocated memory as reserved.
\end{enumerate}

These properties are incompatible with the definition of a mathematical
function. The first one means it is not well defined, and the second one means
it has side effects, which mathematical functions do not have. This motivates
the following definitions:

\begin{definition}[Pure function]
    We say that a procedure that
    \begin{enumerate}
        \item outputs the same result for the same inputs (\ie is well defined),
        \item does not modify global state.
    \end{enumerate}
    is~\emph{pure}.
    Conversely, we say a procedure that is not pure is~\emph{impure}.
\end{definition}

So, the~\mintinline{C}{malloc()} function is impure, and a function that outputs
the result of squaring an integer is pure.

In theory, a compiler could use its knowledge of certain functions being pure to
better reason about code, which can be used to obtain benefits such as

\begin{enumerate}
    \item If a pure function is called more than once with the
        same input, the result calculated on the previous run can be reused
        without having to call the function again~\cite{frostMemorization}. This
        is called~\emph{memorization}

    \item Since pure functions have no side-effects, it is usually safe to call
        them in parallel \cite{SussPureFunctionParallelization}, leading to
        great optimization.
\end{enumerate}

While pure functions present some significant benefits, they also come with some
apparent deficits. For example, it is not obvious how pure functions could react
to user input or output anything to the screen, such as debugging information or
logs. They also seem to be limited to not using global variables.

Most languages circumvent these problems by providing an interface to define
both pure and impure functions. In this way, some of the benefits can be
applied, and the deficits can be handled by impure functions.

As of this point, the problems we mentioned are only apparent, and while it is
not at all obvious how they could be avoided, there is also no definitive proof
they cannot. We promise to provide an abstraction that solves these limitations,
and then we will see how it can be successfully implemented into a useful
programming language.

\section{Monads in Category Theory}
\subsection{Introduction to Category Theory}

\begin{definition}[Category]
    \label{def:category}
    A \emph{category}~\(\cat{C}\) is composed of a collection~\(\Obj(\cat{C})\)
    of \emph{objects}, for every two objects~\(A,B\in\Obj(\cat{C})\) a
    set~\(\Hom_{\cat{C}}(A,B)\) of \emph{morphisms} and a \emph{composition
    function}
    \[
        \circ:\Hom_{\cat{C}}(A,B)\times\Hom_{\cat{C}}(B,C) \longrightarrow
        \Hom_{\cat{C}}(A,C)
    \]
    that satisfies
    \begin{enumerate}
        \item \emph{Associativity}: for every three
            morphisms~\(f\in\Hom_{\cat{C}}(A,B)\),~\(g\in\Hom_{\cat{C}}(B,C)\)
            and~\(h\in\Hom_{\cat{C}}(C,D)\)
            we have
            \[
                h \circ (g \circ f) = (h \circ g) \circ f.
            \]
        \item \emph{Left and right units}: for every
            object~\(A\in\Obj(\cat{C})\) there exists a unique
            element~\(\id_{A}\in\Hom_{\cat{C}}(A,A)\)
            such that for every morphism~\(f\in\Hom_{\cat{C}}(A,B)\) we have
            \[
                f \circ \id_{B} = f,
            \]
            and for every morphism~\(g\in\Hom_{\cat{C}}(B,A)\) we have
            \[
                \id_{A} \circ g = g.
            \]
    \end{enumerate}
\end{definition}

\begin{notation}
    We write~\(f:A\longrightarrow B\) or~\(A\overset{f}{\longrightarrow}B\) to
    mean~\(f\in\Hom_{\cat{C}}(A,B)\) and~\(gf\) to mean~\(g\circ f\).
\end{notation}

\begin{example}[Category of sets]
    \label{cat:set}
    There is a category~\(\Set\), where the objects are sets and morphisms are
    maps between sets.
\end{example}

\begin{definition}[Functor]
    \label{def:functor}
    A~\emph{functor}~\(T\) from a category~\(\cat{C}\) to a category~\(\cat{D}\)
    is a map~\(T:\Obj(\cat{C})\longrightarrow\Obj(\cat{D})\), and for every
    pair of objects~\(A,B\in\Obj{C}\) a
    map~\(T:\Hom_{\cat{C}}(A,B)\longrightarrow\Hom_{\cat{D}}(TA,TB)\),
    such that~\(T\) preserves
    \begin{enumerate}
        \item \emph{Composition}: for every two
            morphisms~\(f:A\longrightarrow B\),~\(g:B\longrightarrow C\)
            in~\(\cat{C}\) we have
            \[
                T(g \circ f) = T(g) \circ T(f).
            \]
        \item \emph{Units}: for each object~\(A\in\Obj{C}\) we have
            \[
                T(\id_{A}) = \id_{T(A)}.
            \]
    \end{enumerate}
\end{definition}

\begin{notation}
    We write~\(T:\cat{C}\longrightarrow\cat{D}\) to mean~\(T\) is a functor from
    a category~\(\cat{C}\) to a category~\(\cat{D}\).
    We may also shorten~\(T(A)\) to~\(TA\) or~\(T(f)\) to~\(Tf\), given~\(A\) an
    object in~\(\cat{C}\) and~\(f\) a morphism in~\(\cat{C}\).
\end{notation}

\begin{definition}[Natural transformation]
    \label{def:natural-transformation}
    Let~\(S,T:\cat{C}\longrightarrow\cat{D}\) be functors. A \emph{natural
    transformation}~\(\tau:S\longrightarrow T\) is a
    family~\(\tau=\{\tau_{A}:SA\longrightarrow TA\}_{A\in\Obj(\cat{C})}\) of
    morphisms in~\(\cat{D}\) such that for every
    morphism~\(f:A\longrightarrow B\) in~\(\cat{C}\)
    \[
        Tf \circ \tau_{A} = \tau_{B} \circ Sf,
    \]
    that is, making the following diagram commutative
    \[
        \begin{tikzcd}
            SA \arrow[r, "\tau_{A}"] \arrow[d, "Sf"] & TA \arrow[d, "Tf"] \\
            SB \arrow[r, "\tau_{B}"] & TB
        \end{tikzcd}
    \]
\end{definition}

\subsection{Monads}
\begin{definition}[Monad]
    \label{def:monad}
    A~\emph{monad} over a category~\(\cat{C}\) is a triple~\((T,\eta,\mu)\)
    where~\(T:\cat{C}\longrightarrow\cat{C}\) is a functor
    and~\(\eta:\id\longrightarrow T\) and~\(\mu:TT\longrightarrow T\) are two
    natural transformations such that for every object~\(A\in\Obj(\cat{C})\) the
    diagrams
    \[
        \begin{tikzcd}
            TA \arrow[r, "T\eta_{A}"] & TTA \arrow[d, "\mu_{A}"] & TA \arrow[l,
            swap, "\eta_{TA}"] \\
                                      & TA \arrow[ul, equal] \arrow[ur, equal] &
        \end{tikzcd}
        \qquad\text{and}\qquad
        \begin{tikzcd}
            TTTA \arrow[r, "\mu_{TA}"] \arrow[d, "T\mu_{A}"] & TTA \arrow[d,
            "\mu_{A}"] \\
            TTA \arrow[r, "\mu_{A}"] & TA
        \end{tikzcd}
    \]
    are commutative. This is
    \[
        \mu_{A}\circ T\eta_{A} = \id_{TA} = \mu_{A}\circ\eta_{TA}
        \qquad\text{and}\qquad
        \mu_{A}\circ \mu_{TA}
        = \mu_{A} \circ T\mu_{A}.
    \]
    We call~\(\eta\) and~\(\mu\) the \emph{unit} and the \emph{multiplication}
    of the monad, respectively.
\end{definition}

\begin{example}[Pointed set monad]
    \label{monad:maybe}
    We define the pointed set monad~\((M,\eta,\mu)\) on the category of
    sets as follows.
    \begin{enumerate}
        \item The functor~\(M\) for any object~\(A\) or
            morphism~\(f:A\longrightarrow B\) is defined as
            \begin{gather*}
                MA = A\sqcup\{\bot\}
                \qquad\text{and}\qquad
                \begin{split}
                    Mf:MA&\longrightarrow MB \\
                    \bot&\longmapsto\bot \\
                    A\ni x&\longmapsto f(x)
                \end{split}
            \end{gather*}
        \item The unit~\(\eta\) for any object~\(A\) is defined as the inclusion
            of~\(A\) into~\(MA\).
        \item The multiplication~\(\mu\) for any object~\(A\) is defined as
            \begin{align*}
                \mu_{A}:MMA&\longrightarrow MA \\
                \bot_{1}&\longmapsto \bot \\
                \bot_{2}&\longmapsto \bot \\
                A\ni x&\longmapsto x
            \end{align*}
            where we have denoted~\(MMA=A\sqcup\{\bot_{1}\}\sqcup\{\bot_{2}\}\)
            and~\(MA=A\sqcup\{\bot\}\) for convenience.
    \end{enumerate}
\end{example}

\begin{example}[Power set monad]
    \label{monad:power-set}
    We define the power set monad~\((P,\eta,\mu)\) on the category of sets as
    follows.
    \begin{enumerate}
        \item The functor~\(P\) for any object~\(A\) or
            morphism~\(f:A\longrightarrow B\) is defined as
            \begin{gather*}
                PA = \mathcal{P}(A)
                \qquad\text{and}\qquad
                \begin{split}
                    Pf:PA&\longrightarrow PB \\
                    S&\longmapsto\{f(x)\in B \mid x\in S\}
                \end{split}
            \end{gather*}
        \item The unit~\(\eta\) for any object~\(A\) is defined
            as~\(\eta_{A}(x)=\{x\}\).
        \item The multiplication~\(\mu\) for any object~\(A\) is defined as
            \begin{align*}
                \mu_{A}:PPA&\longrightarrow PA \\
                S&\longmapsto \bigcup_{X\in S}X
            \end{align*}
    \end{enumerate}
\end{example}

\begin{definition}[Cartesian closed category]
    \label{def:product}
    \label{def:cartesian-closed}
    \label{def:exponential object}
    We say that a category~\(\cat{C}\) is~\emph{Cartesian closed} if
    \begin{enumerate}
        \item For any finite, possibly empty, family of
            objects~\(\{A_{i}\}_{i\in I}\) in~\(\cat{C}\) there is an
            object~\(A=\prod_{i\in I}A_{i}\) in~\(\cat{C}\).
        \item For any two objects~\(A\) and~\(B\) in~\(\cat{C}\) there is
            object~\(B^{A}\) together with a
            morphism~\(\ev:B^{A}\times A\longrightarrow B\) such that for every
            other object~\(C\) and morphism~\(g:C\times A\longrightarrow B\)
            in~\(\cat{C}\) there is a unique
            morphism~\(\lambda g:C\longrightarrow B^{A}\) such that the diagram
            \[\begin{tikzcd}
                C\times A \arrow[dr, "g"] \arrow[d, "\lambda g\times\id_{A}", swap] & \\
                B^{A}\times C \arrow[r, "\ev"] & B
            \end{tikzcd}\]
            commutes.
    \end{enumerate}
    We say that~\(B^{A}\) is the~\emph{exponential object}, and~\(\times\) is
    the~\emph{product}.
\end{definition}

\begin{example}
    The category of sets is Cartesian closed.
\end{example}

\section{The Kleisli Triples in Computer Science}
In section~\ref{sec:motivation} we established that pure functions present some
deficits. Let's put category theory aside for a moment and see how we could work
around some of these, which we will then generalize through categorical notions.
\begin{example}[Non-determinism]
    Suppose we have a procedure~\(A\longrightarrow B\) that has no side-effects
    but is non-deterministic. To model its behaviour through a mathematical
    function we could consider the function
    \[
        f:A\longrightarrow PB.
    \]
    that outputs all of the possible outputs of said procedure for a single
    output, where~\(P\) is the power set functor defined in
    example~\ref{monad:power-set}. Since the original procedure had no
    side-effects, and the new function is clearly deterministic, we can assure
    that~\(f\) is pure, and we can reason about it as a mathematical function.

    Given two such functions~\(f:A\longrightarrow PB\)
    and~\(g:B\longrightarrow PC\), we could compose them by extending~\(g\) to
    \begin{align*}
        g^{\ast}:PB&\longrightarrow PC \\
        S&\longmapsto\{g(x)\in C \mid x\in S\}
    \end{align*}
    and defining the composition of~\(f\) and~\(g\) to be~\(g^{\ast} \circ f\).
    With the same functions, notice that the composition and~\((-)^{\ast}\)
    satisfy
    \[
        g^{\ast}\circ f^{\ast}
        = (g^{\ast} \circ f)^{\ast},
    \]

    As a last observation, we see how if we consider the inclusion
    \begin{align*}
        \eta_{A}:A&\longrightarrow PA \\
        a&\longmapsto\{a\}
    \end{align*}
    we get that~\(\eta_{A}^{\ast}=\id_{PA}\) and, with our new
    composition, we get~\(f^{\ast}\circ\eta_{A}=f\) for every
    function~\(f:A\longrightarrow PB\).
\end{example}

\begin{example}[Side-effects]
    Suppose we have a procedure~\(A\longrightarrow B\) that is deterministic but
    presents side-effects. Modelling its behaviour through a mathematical
    function requires a bit more effort. A function that has side-effects is one
    that modifies global state beyond its scope. To make it pure it would be
    enough to also track the changes made to global state during its execution.
    We could archive this by considering the function
    \[
        f':A\times S\longrightarrow B\times S
    \]
    where~\(S\) contains all possible global states, and~\(f'\) now outputs on
    the first component the result of the original procedure, while on the
    second it outputs the effected state.

    Notice how this also models the behaviour of a function that modifies its
    output depending on global state, even if it does not modify it, as the
    global state is part of its input.

    We can also consider the induced pure function
    \begin{align*}
        f:A&\longrightarrow(B\times S)^{S} \\
        a&\longmapsto\bigr(s\mapsto f'(a,s)\bigl)
    \end{align*}
    where~\(B^{A}\) is the exponential object, of which we are implicitly
    assuming existence.
\end{example}

While not being problems inherent to pure functions, there are other situations
commonly found in computer programming that are also foreign to mathematical
functions, which pure functions behave like.

For example, it is difficult to specify the domain and codomain of a procedure,
which often leads to functions that are not defined on all of their input. An
instance of this is the factorial function, which may be written as
\begin{minted}{python}
def factorial(n: int):
    if n == 0:
        return 1
    elif n >= 1:
        return n * factorial(n - 1)
\end{minted}
This implementation of the factorial function accepts an integer as its input,
but it is not defined for negative values. We call this~\emph{partiality}.

\begin{example}[Partiality]
\end{example}

Another example are~\emph{exceptions}. Procedures often encounter errors during
their execution, which mathematical functions do not, and must signal them to
other functions that have to deal with them, either by passing the exception up
the call chain (eventually aborting the program) or by directly dealing with it
during their execution.

\begin{example}[Exceptions]
\end{example}

\subsection{Kleisli Triple}
\begin{definition}[Kleisli Triple]
    \label{def:kleisli-triple}
    We define a \emph{Kleisli Triple} over a category~\(\cat{C}\)
    as a triple~\((T, \eta, (-)^{\ast})\) consisting of
    \begin{enumerate}
        \item a class function
            \(T:\Obj(\cat{C})\longrightarrow\Obj(\cat{C})\).
        \item \(\forall A\in\cat{C}\)
            a morphism~\(\eta_{A}:A\longrightarrow TA\)
            in~\(\cat{C}\).
        \item \(\forall f:A\longrightarrow TB\)
            a morphism~\(f^{\ast}:TA\longrightarrow TB\).
    \end{enumerate}
    such that
    \begin{enumerate}
        \item For all~\(A\in\cat{C}\) we have
            \({\eta_{A}}^{\ast} = \id_{TA}:TA\longrightarrow TA\).
        \item For all~\(A,B\in\cat{C}\)
            and \(f:A\longrightarrow TB\)
            the diagram
            \[\begin{tikzcd}
                TA \arrow[r, "f^{\ast}"] & TB \\
                A \arrow[u, "\eta_{A}"] \arrow[ur, "f", swap] &
            \end{tikzcd}\]
            commutes. That is~\(f^{\ast}\circ\eta_{A} = f\).
        \item For all~\(f:A\to TB,g:B\to TC\) we
            have~\(g^{\ast}\circ f^{\ast} = (g^{\ast}\circ f)^{\ast}\).
    \end{enumerate}
\end{definition}

\begin{theorem}
    \label{thm:kleisli-triples-and-monads-correspondence}
    Let~\(\cat{C}\) be a category.
    There is a bijective correspondence between Kleisli Triples over~\(\cat{C}\)
    and monads over~\(\cat{C}\).
\end{theorem}
\begin{proof}
    Let~\((T, \eta, (-)^{\ast})\) be a Kleisli triple over~\(\cat{C}\) and set
    \begin{equation}
        \label{eq:monad-unit-in-kleisli-trip}
        \begin{split}
            T:\cat{C} & \longrightarrow\cat{C} \\
            A & \longmapsto TA \\
            f:A\rightarrow B & \longmapsto
            (\eta_{B}\circ f)^{\ast}:TA\rightarrow TB
        \end{split}
    \end{equation}
    and
    \begin{equation}
        \label{eq:monad-prod-in-kleisli-trip}
        \mu_{A} = (\id_{TA})^{\ast}.
    \end{equation}
    We will see that~\((T,\eta,\mu)\) is a monad.

    Let's check that~\(T\) is a functor.
    For every two~\(f:A\longrightarrow B\)
    and~\(g:B\longrightarrow C\)
    morphisms in~\(\cat{C}\)
    we have
    \begin{align*}
        Tg\circ Tf &= (\eta_{C}\circ g)^{\ast}\circ
                      (\eta_{B}\circ f)^{\ast} \\
                   &= \bigl((\eta_{C}\circ g)^{\ast}\circ
                      (\eta_{B}\circ f)\bigr)^{\ast} \\
                   &= \bigl((\eta_{C}\circ g)^{\ast}\circ
                      \eta_{B}\circ f\bigr)^{\ast} \\
                   &= (\eta_{C}\circ g\circ f)^{\ast} \\
                   &= T(g\circ f)
    \end{align*}
    and for all~\(A\in\cat{C}\),
    \[
        T\id_{A} = (\eta_{A}\circ \id_{A})^{\ast} = \eta_{A}^{\ast} = \id_{TA},
    \]
    which proves that~\(T\) is a functor.

    Next we want to see that~\(\mu=\{\mu_{A}\}_{A\in\Obj(\cat{C})}\) is a
    natural transformation.
    Given morphism~\(f:A\longrightarrow B\) in~\(\cat{C}\) we want to prove that
    \[
        Tf \circ \mu_{A} = \mu_{B} \circ TTf.
    \]
    Using~\eqref{eq:monad-prod-in-kleisli-trip} we get
    \begin{gather*}
        \begin{split}
            Tf \circ \mu_{A} &= Tf \circ (\id_{TA})^{\ast} \\
                &= (\eta_{B} \circ f)^{\ast} \circ (\id_{TA})^{\ast} \\
                &= \bigl((\eta_{B} \circ f)^{\ast} \circ \id_{TA}\bigr)^{\ast} \\
                &= \bigl((\eta_{B} \circ f)^{\ast}\bigr)^{\ast} \\
                &= (Tf)^{\ast}
        \end{split}
        \qquad\text{and}\qquad
        \begin{split}
            \mu_{B} \circ TTf &= (\id_{TB})^{\ast} \circ TTf \\
                &= (\id_{TB})^{\ast} \circ (\eta_{TB} \circ Tf)^{\ast} \\
                &= \bigl((\id_{TB})^{\ast} \circ \eta_{TB} \circ Tf\bigr)^{\ast} \\
                &= \bigl(\id_{TB} \circ Tf\bigr)^{\ast} \\
                %&= \bigl(T\id_{B} \circ Tf\bigr)^{\ast} \\
                &= (Tf)^{\ast}
        \end{split}
    \end{gather*}
    and we have proved that~\(\mu\) is a natural transformation.

    We can check that~\(\eta=\{\eta_{A}\}_{A\in\Obj(\cat{C})}\) is also a
    natural transformation.
    By using~\eqref{eq:monad-unit-in-kleisli-trip} we can see that, for any
    morphism~\(f:A\longrightarrow B\) in~\(\cat{C}\), we have
    \[
        Tf \circ \eta_{A}
        = (\eta_{B}\circ f)^{\ast} \circ \eta_{A}
        = \eta_{B} \circ f,
    \]
    which shows that~\(\mu\) is a natural transformation.

    Finally, we can check that~\(\mu\) and~\(\eta\) satisfy the monad laws
    \[
        \mu_{A}\circ T\eta_{A} = \id_{TA} = \mu_{A}\circ\eta_{TA}
        \qquad\text{and}\qquad
        \mu_{A}\circ \mu_{TA}
        = \mu_{A} \circ T\mu_{A}.
    \]
    Using the Kleisli triple laws calculate
    \begin{align*}
        \mu_{A} \circ T\eta_{A}
            &= \mu_{A} \circ (\eta_{TA} \circ \eta_{A})^{\ast} \\
            &= {\id_{TA}}^{\ast} \circ (\eta_{TA} \circ \eta_{A})^{\ast} \\
            &= ({\id_{TA}}^{\ast} \circ \eta_{TA} \circ \eta_{A})^{\ast} \\
            &= \bigl(({T\id_{A}}^{\ast} \circ \eta_{TA}) \circ \eta_{A}\bigr)^{\ast} \\
            &= (T\id_{A} \circ \eta_{A})^{\ast} \\
            &= {\eta_{A}}^{\ast} \\
            &= \id_{TA} \\
            &= {\id_{TA}}^{\ast} \circ \eta_{TA} \\
            &= \mu_{A} \circ \eta_{TA}
    \end{align*}
    and
    \begin{align*}
        \mu_{A} \circ \mu_{TA}
            &= {\id_{TA}}^{\ast} \circ {\id_{TTA}}^{\ast} \\
            &= ({\id_{TA}}^{\ast} \circ \id_{TTA})^{\ast} \\
            &= {\id_{TA}}^{\ast\ast} \\
            &= \bigl(\id_{TA} \circ (\id_{TA})^{\ast}\bigr)^{\ast} \\
            &= \bigl({\id_{TA}}^{\ast} \circ \eta_{TA}\circ(\id_{TA})^{\ast}\bigr)^{\ast} \\
            &= {\id_{TA}}^{\ast} \circ \bigl(\eta_{TA}\circ(\id_{TA})^{\ast}\bigr)^{\ast} \\
            &= {\id_{TA}}^{\ast} \circ T(\id_{TA})^{\ast} \\
            &= \mu_{A} \circ T\mu_{A}
    \end{align*}
    and this proves that a Kleisli Triple induces a monad.

    Let~\((T,\eta,\mu)\) be a monad over~\(\cat{C}\) and for any
    morphism~\(f:A\longrightarrow TB\) in~\(\cat{C}\) set
    \begin{equation}
        \label{eq:kleisli-ast-in-monad}
        f^{\ast} = \mu_{B} \circ Tf.
    \end{equation}
    We want to check that~\((T,\eta,(-)^{\ast})\) is a Kleisli triple.

    By the monad unit law we have
    \[
        {\eta_{TA}}^{\ast} = \mu_{TA} \circ T\eta_{TA} = \id_{TA},
    \]
    and for any two morphisms~\(f:A\longrightarrow TB\)
    and~\(g:B\longrightarrow TC\) in~\(\cat{C}\) we have
    \begin{align*}
        g^{\ast}\circ f^{\ast} &= \mu_{C} \circ Tg \circ \mu_{B} \circ Tf \\
                               &= \mu_{C} \circ \mu_{TC} \circ TTg \circ Tf \\
                               &= \mu_{C} \circ T\mu_{C} \circ TTg \circ Tf \\
                               &= \mu_{C} \circ T(\mu_{C} \circ Tg \circ f) \\
                               &= \mu_{C} \circ T(g^{\ast} \circ f) \\
                               &= (g^{\ast} \circ f)^{\ast}
    \end{align*}

    Then, for any morphism~\(f:A\longrightarrow TB\) in~\(\cat{C}\) we can use
    the unit law to get
    \begin{align*}
        f^{\ast} \circ \eta_{A}
            &= \mu_{B} \circ Tf \circ \eta_{A} \\
            &= \mu_{B} \circ \eta_{TB} \circ f \\
            &= \id_{TB} \circ f \\
            &= f
    \end{align*}
    and this proves that every monad induces a Kleisli Triple.

    It is clear that these two constructions are inverse to each other.
\end{proof}

\subsection{The Kleisli category}
For this definition to be useful we must also show that the defined morphisms
are well behaved in some sense. At the very minimum, we should be able to
compose them and there should be a unit function.

We show that they actually form a category, and give an explicit formula for
their composition and units.

\begin{proposition}[The Kleisli category]
    Given a Kleisli triple~\((T,\eta,(-)^{\ast})\) over a category~\(\cat{C}\),
    the following data forms a category~\(\cat{C}_{T}\), which we call
    the~\emph{Kleisli category}.
    \begin{enumerate}
        \item The objects~\(\Obj(\cat{C}_{T}) = \Obj(\cat{C})\).
        \item For any two objects~\(A,B\) in~\(\cat{C}_{T}\), the morphisms
            \[
                \Hom_{\cat{C}_{T}}(A,B) = \Hom_{C}(A,TB).
            \]
        \item For any two
            morphisms~\(f:A\longrightarrow TB\),~\(g:B\longrightarrow TC\)
            in~\(\cat{C}_{T}\), the composition
            \[
                g \circ_{T} f = g^{\ast} \circ f.
            \]
    \end{enumerate}
\end{proposition}
\begin{proof}
    We start by checking that the composition is associative. For any three
    morphisms~\(f:A\longrightarrow TB\),~\(g:B\longrightarrow TC\)
    and~\(h:C\longrightarrow TD\) in~\(\cat{C}_{T}\) we have
    \begin{align*}
        h \circ_{T} (g \circ_{T} f)
            &= h^{\ast} \circ (g \circ_{T} f) \\
            &= h^{\ast} \circ (g^{\ast} \circ f) \\
            &= (h^{\ast} \circ g^{\ast}) \circ f \\
            &= (h^{\ast} \circ g)^{\ast} \circ f \\
            &= (h^{\ast} \circ g) \circ_{T} f \\
            &= (h \circ_{T} g) \circ_{T} f,
    \end{align*}
    were we have used the third property of Kleisli triples.

    We can also see that for every object~\(A\) in~\(\Obj(\cat{C}_{T})\) there
    is a unit morphism~\(\id_{A}\). If we take
    \[
        \id_{A} = \eta_{A}
    \]
    then for every morphism~\(f:A\longrightarrow TB\) in~\(\cat{C}_{T}\) we have
    \begin{align*}
        f \circ_{T} \id_{A}
        &= f \circ_{T} \eta_{A} \\
        &= f^{\ast} \circ \eta_{A} \\
        &= f
    \end{align*}
    and for every morphism~\(g:B\longrightarrow TA\) in~\(\cat{C}_{T}\) we have
    \begin{align*}
        \id_{A} \circ_{T} g
        &= \eta_{A} \circ_{T} g \\
        &= \eta_{A}^{\ast} \circ g \\
        &= \id_{TA} \circ g \\
        &= g
    \end{align*}
    by using the first and second properties of Kleisli triples.

    This is enough to check that the construction satisfies the definition of a
    category given in~\ref{def:category}.
\end{proof}

\section{Monads in Haskell}
\subsection{Haskell}
\subsection{The \texorpdfstring{\mintinline{Haskell}{Monad}}{Monad} typeclass}
The Haskell language allows users to define~\emph{typeclasses}, which area set
of constraints we give to a certain set of types.
They are similar to interfaces, which appear in other languages.

For our purposes, we can picture them as a definition. A typeclass describes a
behavior we expect.

Let's see an example. The~\mintinline{Haskell}{Functor} typeclass is
\begin{minted}{Haskell}
class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{minted}
From the usage of~\mintinline{Haskell}{f}, the Haskell compiler can infer
that it must be a parametric type with one parameter, and
with this information we can read the previous statement as
\begin{quote}
    For a parametric datatype~\mintinline{Haskell}{f} with one parameter to be
    called a Functor, it must be equipped with a structure

    \mintinline{Haskell}{fmap :: (a -> b) -> f a -> f b}
\end{quote}

Let's see an example of an implementation. If we define the parametric data
type~\mintinline{Haskell}{Maybe} as follows
\begin{minted}{Haskell}
data Maybe a = Just a | None
\end{minted}
we can make it into a Functor by writing
\begin{minted}{Haskell}
instance Functor Maybe where
    fmap :: (a -> b) -> Maybe a -> Maybe b
    fmap _ Nothing  = Nothing
    fmap f (Just x) = Just (f x)
\end{minted}
where we first declare that we want to show that~\mintinline{Haskell}{Maybe a}
is a~\mintinline{Haskell}{Functor}, which we do by providing a definition
for~\mintinline{Haskell}{fmap :: (a -> b) -> Maybe a -> Maybe b}.

Given a parametric datatype~\mintinline{Haskell}{f a}, the functor typeclass
provides a function that can be understood as having
type~\mintinline{Haskell}{fmap :: (a -> b) -> (f a -> f b)}, which reminds us of
the property of functors to act on functions. Additionally, the parametric
datatype itself acts on types, by transforming an existing type into a new one,
behaviour similar to that of a functor.

This is no enough for a function on objects and morphisms to be a functor. The
functor laws must be satisfied as well. The Haskell language does not provide a
way to express such laws, since for this it would need a way to write and
validate proofs, which would add too much complexity to the language. The
compiler assumes any typeclass implementations it encounters satisfy such
properties, which are only generally found in external documentation. Failing to
satisfy these laws could lead to buggy code and unintended behaviour.

We will not prove typeclass laws for specific instances we provide in this
section, as the proofs are usually straightforward but uncomfortable to write.

The laws for the functor typeclass are
\begin{minted}{Haskell}
fmap id = id
fmap (f . g) = (fmap f . fmap g)
\end{minted}
that are clearly equivalent to the functor laws found in~\ref{def:functor}.
The~\mintinline{Haskell}{f} that appears in these laws is different from
the~\mintinline{Haskell}{f} found in the definition of
the~\mintinline{Haskell}{Functor} typeclass, since it now corresponds to an
arbitrary function. This misleading use of notation happens often in Haskell,
and will be repeated in further typeclass laws in this document.

There is a notion of~\emph{inheritance} of typeclasses. Typeclass inheritance is
when a typeclass has a superclass. This is a way of expressing that a typeclass
requires another typeclass to be available for a given type before you can write
an instance. For example, Haskell provides a class that inherits
from~\mintinline{Haskell}{Functor}
\begin{minted}{Haskell}
class Functor f => Applicative f where
    (<*>) :: f (a -> b) -> f a -> f b
    pure :: a -> f a
\end{minted}
the~\mintinline{Haskell}{=>} notation is unfortunate, as in math it is usually
associated with an implication.

In this situation, to prove that a datatype is
an~\mintinline{Haskell}{Applicative}, we must first prove it is
a~\mintinline{Haskell}{Functor}, and then provide implementations for the two
required functions.
The laws for the~\mintinline{Haskell}{Applicative} typeclass are
\begin{minted}{Haskell}
pure id <*> v = v
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
pure f <*> pure x = pure (f x)
u <*> pure y = pure ($ y) <*> u
\end{minted}
and we can make~\mintinline{Haskell}{Maybe}, which we know to be
a~\mintinline{Haskell}{Functor}, into an~\mintinline{Haskell}{Applicative}
\begin{minted}{Haskell}
instance Applicative Maybe where
    (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
    (<*>) (Just f) m = fmap f m
    (<*>) _ _ = Nothing

    pure :: a -> Maybe a
    pure = Just
\end{minted}
this class coincides with the notion of lax monoidal functor, which is not
related to our topic. They are used to define the~\mintinline{Haskell}{Monad}
typeclass.

\begin{minted}{Haskell}
class Applicative m => Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    (>>) :: m a -> m b -> m b
    return :: a -> m a
\end{minted}
where~\mintinline{Haskell}{(>>=)} is called~\emph{bind}.
Any~\mintinline{Haskell}{Monad} implementation must satisfy
\begin{minted}{Haskell}
return a >>= k = k a
m >>= return = m
m >>= (\x -> k x >>= h) = (m >>= k) >>= h

k >> f = k >>= \_ -> f

pure = return
m1 <*> m2 = m1 >>= (x1 -> m2 >>= (x2 -> return (x1 x2)))
\end{minted}
finally, we can make~\mintinline{Haskell}{Maybe}, which we know to be
an~\mintinline{Haskell}{Applicative}, into a~\mintinline{Haskell}{Monad}
\begin{minted}{Haskell}
instance Monad Maybe where
    (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
    Just x  >>= k = k x
    Nothing >>= _ = Nothing

    (>>) :: Maybe a -> Maybe b -> Maybe b
    Just _  >> m = m
    Nothing >> _ = Nothing

    return :: a -> Maybe a
    return = pure
\end{minted}

\subsection{Haskell monads are monads}
The~\mintinline{Haskell}{Monad} structure defined by Haskell
\begin{minted}{Haskell}
class Applicative m => Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    (>>) :: m a -> m b -> m b
    return :: a -> m a
\end{minted}
subject to the laws
\begin{minted}{Haskell}
return a >>= k = k a
m >>= return = m
m >>= (\x -> k x >>= h) = (m >>= k) >>= h

k >> f = k >>= \_ -> f

pure = return
m1 <*> m2 = m1 >>= (x1 -> m2 >>= (x2 -> return (x1 x2)))
\end{minted}
does not correspond, at first sight, to the definition of monad given
in~\ref{def:monad}.

We begin observing that the~\mintinline{Haskell}{Monad}
operation~\mintinline{Haskell}{(>>)} can be uniquely determined in terms
of~\mintinline{Haskell}{(>>=)}, the bind operation.
This means that we can omit this operation from our reasoning. In fact, it is
only defined because it is useful in a programming setting, and bears no
particular mathematical relevance to us.

Our next observation lies on the bind operation. If we flip its arguments, we
get an operation with type signature
\begin{minted}{Haskell}
(a -> m b) -> (m a -> m b)
\end{minted}
which coincides with the~\((-)^{\ast}\) operation, while the type signature for
the~\mintinline{Haskell}{return} function coincides with~\(\eta_{A}\)
(where~\(A\) is determined by context in the Haskell program), as defined in the
definition of Kleisli triple in~\ref{def:kleisli-triple}.

With this correspondence we can now prove that the~\mintinline{Haskell}{Monad}
structure defined by Haskell is a monad by first showing that it is a Kleisli
triple, and then using
theorem~\ref{thm:kleisli-triples-and-monads-correspondence}. This can be shown
directly from the first three~\mintinline{Haskell}{Monad} laws.

\printbibliography

\end{document}

